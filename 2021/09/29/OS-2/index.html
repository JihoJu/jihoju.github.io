<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Process(프로세스)란?? - Jiho Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Jiho Blog"><meta name="msapplication-TileImage" content="/img/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Jiho Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="들어가며..Program, process 와 같이 비슷한 단어들을 보며 대체 프로세스는 뭐고 프로그램은 뭐지? 둘 다 똑같은 거 아닌가? 엄청 헷갈렸다. 이번 포스팅에서는 대체 프로세스가 무엇이고 프로그램과 어떻게 구별되는지 정리하고 프로세스의 상태(State)에 대해 정리해보려고 합니다. :) 프로세스를 정리하기에 앞서 Vitualizaion 과 관련해서"><meta property="og:type" content="blog"><meta property="og:title" content="Process(프로세스)란??"><meta property="og:url" content="http://example.com/2021/09/29/OS-2/"><meta property="og:site_name" content="Jiho Blog"><meta property="og:description" content="들어가며..Program, process 와 같이 비슷한 단어들을 보며 대체 프로세스는 뭐고 프로그램은 뭐지? 둘 다 똑같은 거 아닌가? 엄청 헷갈렸다. 이번 포스팅에서는 대체 프로세스가 무엇이고 프로그램과 어떻게 구별되는지 정리하고 프로세스의 상태(State)에 대해 정리해보려고 합니다. :) 프로세스를 정리하기에 앞서 Vitualizaion 과 관련해서"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/OS/os_cover.jpeg"><meta property="article:published_time" content="2021-09-29T11:18:15.000Z"><meta property="article:modified_time" content="2021-09-29T11:20:16.525Z"><meta property="article:author" content="Jiho Ju"><meta property="article:tag" content="OS, Operating System, Process"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/OS/os_cover.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/09/29/OS-2/"},"headline":"Process(프로세스)란??","image":[],"datePublished":"2021-09-29T11:18:15.000Z","dateModified":"2021-09-29T11:20:16.525Z","author":{"@type":"Person","name":"Jiho Ju"},"publisher":{"@type":"Organization","name":"Jiho Blog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.png"}},"description":"들어가며..Program, process 와 같이 비슷한 단어들을 보며 대체 프로세스는 뭐고 프로그램은 뭐지? 둘 다 똑같은 거 아닌가? 엄청 헷갈렸다. 이번 포스팅에서는 대체 프로세스가 무엇이고 프로그램과 어떻게 구별되는지 정리하고 프로세스의 상태(State)에 대해 정리해보려고 합니다. :) 프로세스를 정리하기에 앞서 Vitualizaion 과 관련해서"}</script><link rel="canonical" href="http://example.com/2021/09/29/OS-2/"><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Jiho Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jiahho"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/OS/os_cover.jpeg" alt="Process(프로세스)란??"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021, 09 29" title="2021. 9. 29. 오후 8:18:15">2021-09-29</time></span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Process(프로세스)란??</h1><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며.."></a>들어가며..</h1><p>Program, process 와 같이 비슷한 단어들을 보며 대체 프로세스는 뭐고 프로그램은 뭐지? 둘 다 똑같은 거 아닌가? 엄청 헷갈렸다. 이번 포스팅에서는 대체 프로세스가 무엇이고 프로그램과 어떻게 구별되는지 정리하고 프로세스의 상태(State)에 대해 정리해보려고 합니다. :) 프로세스를 정리하기에 앞서 Vitualizaion 과 관련해서 프로세스의 개념이 많이 쓰이다 보니 함께 다시 정리하면 좋을 거 같아 Virtualizaioin에 대해 짧게 정리하겠습니다.</p>
<span id="more"></span>

<h1 id="Virtualizion"><a href="#Virtualizion" class="headerlink" title="Virtualizion"></a>Virtualizion</h1><h2 id="CPU-Vituralizion"><a href="#CPU-Vituralizion" class="headerlink" title="CPU Vituralizion"></a>CPU Vituralizion</h2><p>다수의 Process, User 중 각각의 개별 process, user들이 자신만의 CPU를 가지고 있다는 illusion을 제공하는 것이다. 이를 가능하게 하는 개념이 <strong>Time-Sharing</strong> 이다.</p>
<h3 id="Time-Sharing"><a href="#Time-Sharing" class="headerlink" title="Time-Sharing"></a>Time-Sharing</h3><p>사용자들에게 그들이 원하는 대로 동시에 많은 프로세스가 실행되는 것처럼 실행시켜준다.</p>
<p><img src="/img/OS/os3_1.png" alt="그림 1"></p>
<p>[그림 1]을 보면 각 프로세스가 동시에 수행되는 듯한 효과를 주기 위해 지정된 time-slice 만큼 실행되는 것을 볼 수 있다. 이를 통해 Round-robin fashioin 방식으로 한 프로세스를 실행하고 stop하고 또다른 프로세스를 실행하는 과정이 time-sharing 이라는 것을 알 수 있다.</p>
<p>Time-sharing 방식의 메커니즘 과정을 좀 더 자세히 정리해보자.</p>
<p>프로세스 P1 의 시간이 끝났다거나 I/O 등이 발생해서 P1이 stop되고 P2가 실행된다고 가정해보자. 그럼 P1의 <strong>Context(프로세스를 수행하기위한 정보)</strong> 를 다른 곳에 저장 후 다음에 실행될 P2를 위한 Context 로 바뀌어야한다. 이 과정이 <strong>Context Switching</strong> 이다.</p>
<p>CPU의 레지스터의 개수는 제한적이라 공통 레지스터를 사용하기에 Context Switching이 필요하다.</p>
<p><strong>Time-sharing을 가능하게 하기 위해 전제조건</strong> 이 필요하다. 전제조건은 다음과 같다.</p>
<h3 id="OS’s-low-level-mechanism-How-e-g-Context-switch"><a href="#OS’s-low-level-mechanism-How-e-g-Context-switch" class="headerlink" title="OS’s low-level mechanism (How) e.g. Context switch"></a>OS’s low-level mechanism (How) e.g. Context switch</h3><p>여러 프로세스를 실행할 때 프로세스 단 하나만 실행됐을 때랑 같은 결과를 보장해주기 위해 Context Switch 가 안전하고 효율적으로 저장, 수행되야 한다.</p>
<h3 id="OS’s-policy-Which-e-g-Scheduling-policies"><a href="#OS’s-policy-Which-e-g-Scheduling-policies" class="headerlink" title="OS’s policy (Which) e.g. Scheduling policies"></a>OS’s policy (Which) e.g. Scheduling policies</h3><p>다음에는 어떤 프로세스를 수행할 것인지 CPU가 알아야 CPU가 해당 프로세스를 수행할 것이다.</p>
<p>프로세스 P1이 1초가 수행되고 Stop 시 P2, P3 둘 중 무엇을 실행할 지 CPU는 알지 못한다. 어떤 순서로 어떤 프로세스를 다음에 수행할 지를 <strong>Scheduling Policy</strong> 에 의해 OS가 처리해줘야한다.</p>
<h2 id="Memory-Virtualizion"><a href="#Memory-Virtualizion" class="headerlink" title="Memory Virtualizion"></a>Memory Virtualizion</h2><p>다수의 Process, User 중 각각의 개별 process, user들이 자신만의 메모리를 가지고 있다는 illusion을 제공하는 것이다. 그럼 가상 메모리는 어떻게 구성되는지 알아보자.</p>
<p><img src="/img/OS/os3_2.png" alt="그림 2"></p>
<h3 id="가상-메모리의-용량-32-bit-CPU-기준"><a href="#가상-메모리의-용량-32-bit-CPU-기준" class="headerlink" title="가상 메모리의 용량 (32 bit CPU 기준)"></a>가상 메모리의 용량 (32 bit CPU 기준)</h3><p>32bit 에선 명령어, 주소, 데이터 등이 <strong>32bit(8Byte) 단위</strong> 로 움직인다.</p>
<p>나타낼 수 있는 개수는 0000 0000 0000 0000 ~ FFFF FFFF FFFF FFFF 로 2^32개가 존재한다. 주소 하나는 1Byte이기에 주소는 2^32개로 표현이 가능하니 가상 메모리 공간은 <strong>2^32Byte(4GB)</strong> 가 된다.</p>
<p>주소 하나가 1Byte 단위를 가지는 이유는 표현할 수 있는 작은 데이터 type이 **Char(1byte)**이므로 이 데이터 타입의 크기를 단위로 설정해야 <strong>메모리 낭비</strong>를 줄일 수 있다.</p>
<h3 id="Kernel-OS-영역"><a href="#Kernel-OS-영역" class="headerlink" title="Kernel(OS) 영역"></a>Kernel(OS) 영역</h3><p>컴퓨터 전원을 키게 되면 booting을 하는 동안 OS라는 큰 프로세스가 이 메모리 공간에 업로드된다.</p>
<h3 id="Stack-영역"><a href="#Stack-영역" class="headerlink" title="Stack 영역"></a>Stack 영역</h3><p>이 영역은 간단히 말하자면 <strong>함수들이 담기는 공간</strong>이다.</p>
<p>만약 main 함수 내에 10개의 함수들이 존재한다고 가정해보자.</p>
<p>main 함수를 실행하자마자 이 10개의 함수를 바로 메모리(stack)에 올리는게 과연 효율적인가? <strong>절대 아니다.</strong> 메모리는 제한적이기에 이 방법은 효율적이지 않다. 그럼 그때마다 필요한 함수만 메모리(stack)에 올리는 방법을 생각할 수 있다.</p>
<p>function 1, 변수 3개 ⇒ 일단 이 함수만 stack에 할당 후 끝나면 모두 날려!</p>
<p>function 2, 변수 5개 ⇒ 그 다음 이 함수만을 stack에 할당 후 끝나면 날려!</p>
<p>이 과정을 통해 함수들이 stack 영역에 할당된다. 이러한 과정 때문에 <strong>dynamic memory</strong></p>
<p>라 불린다.</p>
<h3 id="Heap-영역"><a href="#Heap-영역" class="headerlink" title="Heap 영역"></a>Heap 영역</h3><p>프로그래머들에 의해 관리되는 영역으로 추가 메모리가 필요할 때마다 동적으로 프로그래머가 이 영역의 메모리를 할당 받을 수 있다. malloc() 함수가 있다.</p>
<h3 id="Static-Data-Literals-영역"><a href="#Static-Data-Literals-영역" class="headerlink" title="Static Data, Literals 영역"></a>Static Data, Literals 영역</h3><ul>
<li>  Static Data 영역에는 정적(static) 변수, 전역(global) 변수가 할당된다. 이러한 변수들은 읽고 쓸 수 있다.</li>
<li>  Literals 영역에는 문자열 등이 할당되는데 이 문자열들은 평소에 생각하는 문자열이 아닌 오로지 읽을 수만 있다.</li>
</ul>
<h3 id="Instructions-영역"><a href="#Instructions-영역" class="headerlink" title="Instructions 영역"></a>Instructions 영역</h3><p>코드들이 이 영역에 할당된다.</p>
<hr>
<h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><p>프로세스란 <strong>OS로부터 제공되는 실행 프로그램에 대한 추상적 개념</strong> 이다. CPU에 의해 실행(execute)될 준비가 되어 메모리에 올라와 있는 실행 중인 프로그램이다.</p>
<h3 id="그럼-대체-프로그램이랑-프로세스의-차이가-무엇인가"><a href="#그럼-대체-프로그램이랑-프로세스의-차이가-무엇인가" class="headerlink" title="그럼 대체 프로그램이랑 프로세스의 차이가 무엇인가??"></a><strong>그럼 대체 프로그램이랑 프로세스의 차이가 무엇인가??</strong></h3><p><strong>Program(프로그램)</strong> 은 디스크(disk)에 존재하는 실행 가능한 파일이며 <strong>Process(프로세스)</strong> 는 프로그램을 실행하여 이 프로그램이 cpu에 의해 실행되기 위해 메인 메모리에 업로드된 것이다.</p>
<h2 id="프로세스-생성-Process-Creation"><a href="#프로세스-생성-Process-Creation" class="headerlink" title="프로세스 생성(Process Creation)"></a>프로세스 생성(Process Creation)</h2><p><img src="/img/OS/os3_3.png" alt="그림 3"></p>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p><strong>Program</strong> 들은 초기에 <strong>실행 가능한 파일(executable format)</strong> 으로 디스크에 저장되어 있다.</p>
<p>프로그램을 실행하면 program code가 메모리(프로세스의 주소 공간)로 load 된다.</p>
<p>이를 OS가 처리하는데 <strong>OS는 프로세스를 “lazily”하게 loading</strong> 한다. 이는 <strong>메모리에 모든 프로그램의 내용을 한번에 loading 하지 않고 그때마다 꼭 필요한 것들만 loading</strong> 하다는 의미이다. 당연히 이에 필요한 정책이 존재한다.</p>
<h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p><strong>Stack 영역이 할당</strong>되고 <strong>Heap 영역이 생성</strong>된다.</p>
<p><strong>Stack 영역</strong>은 local variables, function parameters, and return address 를 위해 사용되며 main() function의 argc, argv array 인자들과 함께 initialize 된다.</p>
<p><strong>Heap 영역</strong>은 동적으로 요청되어 할당된 data 들을 위해 사용되며 프로그램은 malloc()를 호출하여 이 영역을 요청하며 free()를 호출하여 할당된 영역을 free 시킨다.</p>
<h3 id="The-OS-do-some-other-initializaion-tasks"><a href="#The-OS-do-some-other-initializaion-tasks" class="headerlink" title="The OS do some other initializaion tasks"></a>The OS do some other initializaion tasks</h3><p><strong>Input/output (I/O)를 Setup</strong> 한다.<br>각 프로세스는 기본적으로 세 개의 <strong>open file descriptor</strong> 를 가지고 있다. <strong>Standard input</strong>, <strong>output</strong>, and <strong>error</strong> 가 있다.</p>
<h3 id="Decode-and-Execution"><a href="#Decode-and-Execution" class="headerlink" title="Decode and Execution"></a>Decode and Execution</h3><p>OS는 CPU 권한을 새롭게 생긴 프로세스에게 넘겨주며 <strong>entry point(main())</strong> 에서 프로그램을 실행한다.</p>
<h2 id="프로세스-상태-Process-States"><a href="#프로세스-상태-Process-States" class="headerlink" title="프로세스 상태(Process States)"></a>프로세스 상태(Process States)</h2><p>프로세스가 동작하고 수행되는데 있어 <strong>“상태(status)”</strong> 는 아주 중요한 개념이다. 프로세스는 다양한 상태를 가지며 계속 상태가 바뀌면서 동작하기에 <strong>“Active entity”</strong> 라고도 한다. (Program은 passive entity)</p>
<p>프로세스가 수행될 때 <strong>프로세스의 상태를 결정 혹은 파악할 수 있는 것은 메모리와 레지스터의 상태(state)</strong> 이다.</p>
<p><strong>Machine State</strong>(간단히 상태)를 설명하기 위해선 <strong>ISA(Instruction Set Architecture)</strong> 의 개념이 필요하다. Machine State는 간단히 말하면 명령어를 주었을 때 하드웨어의 state가 하나씩 바뀌는 것이다.</p>
<p>이와 같이 명령어 집합(ISA)의 핵심 역할은 <strong>상태(state)</strong> 를 바꾸는 것이다. 위에서 프로세스의 상태를 결정하는 건 메모리와 레지스터의 상태라고 언급했다. 그럼 어떻게 상태가 변하는 지 메모리에 loading된 프로세스가 수행되는 메커니즘을 통해 살펴보자.</p>
<p><img src="/img/OS/os3_4.png" alt="그림 4"></p>
<ul>
<li>  <strong>레지스터</strong>: 프로세스 실행 시 메모리에 있는 정보를 레지스터에 load ⇒ 레지스터의 값이 변경되며 레지스터의 state는 변한다.</li>
<li>  <strong>메모리</strong>: 레지스터의 값을 출력 후 이를 메모리에 다시 저장 ⇒ 메모리의 값이 변경되며 메모리의 state 역시 바뀐다.</li>
</ul>
<p><strong>정리하자면 프로세스는 상태(State)가 바뀌면서 동작한다! 이 상태를 결정하는 것은 메모리와 레지스터의 상태이다!</strong></p>
<p>그럼 프로세스의 각 상태(State)를 알아보자.<br>여기서 프로세스의 상태 모델 <strong>5-State Model</strong>과 <strong>7-State Model</strong> 2가지를 정리하겠다.</p>
<h3 id="5-State-Model"><a href="#5-State-Model" class="headerlink" title="5-State Model"></a>5-State Model</h3><p><img src="/img/OS/os3_5.png" alt="그림 5"></p>
<ul>
<li><strong>New(Creation)</strong><br>  이 상태(State)는 <strong>프로세스가 수행되는데 필요한 자원(CPU 자원, 코드, 데이터 등)이 없거나 메모리에 올라가지 않은 상태</strong> 이다.<br>  이 State는 <strong>프로세스를 생성</strong>하고 <strong>OS에게 생성된 프로세스의 기본 정보를 알려주는 State</strong>이다. (쉽게 생각하면 <strong>출생 신고</strong>와 같다)</li>
<li><strong>Running</strong><br>  이 상태(State)는 <strong>메모리의 프로세스가 CPU에 의해 실행되고 있는 State</strong> 이다.<br>  <strong>Processor 와 수행되는데 필요한 모든 자원을 갖추고 있는 상태이며 한 시점에 Running State를 가진 프로세스는 단 하나뿐이다!!</strong></li>
<li><strong>Ready</strong><br>  이 상태는 프로세스가 <strong>실행되는데 필요한 자원을 Processor를 제외하고 다 갖추고 있어 자기 차례가 되면 언제든지 수행(dispatch)될 수 있는 State</strong> 이다.<br>  쉽게 정리하면 <strong>기다리는 상태</strong>이다. Running State에서 time-sharing에 의해 time-out 되서 stop 되면 Ready Queue 의 맨 뒤로 이동하며 Ready State로 바뀐다. 그리고 OS에 의해 scheduled(dispatch)될 때까지 wait 한다.<ul>
<li>  <strong>Dispatch(=Scheduled)</strong>: 프로세스가 ready queue에서 내 순서가 되어 running state로 바뀌는 것</li>
</ul>
</li>
<li><strong>Blocked(Wait)</strong><br>  이 상태(State)는 <strong>프로세스가 수행되기에 필요한 자원들이 부족한 State</strong> 이다.<br>  Running State 에 있던 <strong>프로세스가 수행되는데 필요한 자원이 필요해 disk에게 I/O request를 하게 되면 프로세스의 상태가 Blocked State로 바뀌게 되며 필요 자원이 올 때까지 이 상태에서 대기한다.</strong><br>  프로세스는 수행하기에 필요한 자원을 받고 <strong>수행 준비 완료되면 Ready State로 바뀌게된다.</strong> (Ready Queue 맨 뒤로 이동) ⇒ 이 것을 <strong>“Wakeup”</strong> 이라 한다.</li>
<li><strong>Exit(Terminated)</strong><br>  이 상태(State)는 <strong>프로세스 수행이 완료되어 모든 Queue와 메인 메모리로부터 제거되고 할당된 자원을 release하고 OS로 다시 return 하는 State</strong> 이다. PCB 또한 삭제된다.</li>
</ul>
<h3 id="7-State-Model"><a href="#7-State-Model" class="headerlink" title="7-State Model"></a>7-State Model</h3><p><img src="/img/OS/os3_6.png" alt="그림 6"></p>
<p>7-State Model 은 5-State Model 에서 <strong>더 많은 프로세스들을 메모리에 loading 하는데 있어 필요한 메모리의 용량(capacity of main memory) 을 고려하여 2가지 State를 추가한 것</strong> 이다.</p>
<p>만약 메인 메모리가 가득 찼다고 가정해보자. 만약 지금 꼭 수행해야 하는 프로세스가 있으면 이를 메모리에 올려야 할 것이다. 메모리가 가득 찼으니 현재 메모리에 업로드되어 있는 덜 중요한 프로세스를 빼고 새로운 프로세스를 loading 해줘야 할 것이다. 현재 메모리에 업로드 되어 있는 프로세스를 잠시 disk로 빼주는 것을 <strong>Swap Out</strong> 이라 하며 새로운 프로세스를 disk에서 메모리로 loading 해주는 것이 <strong>Swap In</strong> 이라 한다. <strong>Swap In, Swap Out</strong> 하는 과정을 <strong>Swapping</strong> 이라 한다.</p>
<p>어떤 프로세스를 Swap Out 할 지를 결정하는 정책(Policy)이 필요하다. 성능 속도를 비교하면 프로세서 &gt; 메모리 &gt; 디스크 이다. 메인 메모리와 디스크 간에 프로세스 이동이기 때문에 잘못 suspend 하게 되면 컴퓨터 성능에 영향을 미칠 수 있기 때문에 정책이 필요하다.</p>
<h3 id="Ready-State-와-Blocked-Wait-State의-차이"><a href="#Ready-State-와-Blocked-Wait-State의-차이" class="headerlink" title="Ready State 와 Blocked(Wait) State의 차이"></a>Ready State 와 Blocked(Wait) State의 차이</h3><p>프로세스가 수행될 때 Stop 되는 건 똑같다.<br><strong>Ready State</strong> 는 time-sharing 에 의한 time-out 으로 stop 된 반면 <strong>Blocked State</strong> 는 I/O 요청으로 인해 Stop 되는 것이다.</p>
<p>그럼 <strong>I/O가 발생하게 되면 Ready State 로 안가고 굳이 왜 Blocked State 로 가는지 의문</strong>이 들 것이다.</p>
<p>만약 scanf 명령어를 수행한다고 가정해보자. <strong>키보드로부터 데이터를 받아야 하기 때문에 OS가 I/O를 요청</strong>한다. 이 상황에서 <strong>자기 차례가 와도 프로세스를 수행하기에 필요한 자원이 없어 프로세스 수행이 불가</strong>하다. 그렇기에 <strong>Blocked State에서 프로세스를 수행하기에 필요한 자원을 할당 받고 수행할 준비가 되면 Ready State 로 바뀌는 것</strong> 이다.</p>
<h3 id="Preemption-과-Block-Wait-Sleep-의-차이"><a href="#Preemption-과-Block-Wait-Sleep-의-차이" class="headerlink" title="Preemption 과 Block/Wait/Sleep 의 차이"></a>Preemption 과 Block/Wait/Sleep 의 차이</h3><p>둘의 개념을 명확히 할 필요가 있어서 정리했다.(내가 너무 헷갈려서,,,) 둘 다 running state 에 있는 프로세스를 stop 한다는 것은 똑같다.</p>
<ul>
<li><strong>Preemption</strong><br>  프로세스의 State가 <strong>Running State → Ready State</strong> 로 바뀌는 것이다. 이유는 2가지가 있다.<ol>
<li>Time-sharing 으로 인해 time-out 됐을 경우</li>
<li>우선 순위 고려 시 우선 순위가 낮은 프로세스를 preemption 후 우선 순위가 높은 프로세스를 실행하는 경우</li>
</ol>
</li>
<li><strong>Block/Wait/Sleep → Interrupt 과 비슷!!</strong><br>  프로세스의 State가 <strong>Running State → Blocked State</strong> 로 바뀌는 것이다.<ol>
<li>프로세스를 계속 수행하는데 있어 필요 자원을 요청하는 경우 (I/O or System call completion)</li>
</ol>
</li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS-Operating-System-Process/">OS, Operating System, Process</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6131c8caef517e00138503b3&amp;product=sticky-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/17/OS-1-5/"><span class="level-item">Schematic Overview of Computer System</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#들어가며"><span class="level-left"><span class="level-item">1</span><span class="level-item">들어가며..</span></span></a></li><li><a class="level is-mobile" href="#Virtualizion"><span class="level-left"><span class="level-item">2</span><span class="level-item">Virtualizion</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CPU-Vituralizion"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">CPU Vituralizion</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Time-Sharing"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Time-Sharing</span></span></a></li><li><a class="level is-mobile" href="#OS’s-low-level-mechanism-How-e-g-Context-switch"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">OS’s low-level mechanism (How) e.g. Context switch</span></span></a></li><li><a class="level is-mobile" href="#OS’s-policy-Which-e-g-Scheduling-policies"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">OS’s policy (Which) e.g. Scheduling policies</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Memory-Virtualizion"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Memory Virtualizion</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#가상-메모리의-용량-32-bit-CPU-기준"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">가상 메모리의 용량 (32 bit CPU 기준)</span></span></a></li><li><a class="level is-mobile" href="#Kernel-OS-영역"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">Kernel(OS) 영역</span></span></a></li><li><a class="level is-mobile" href="#Stack-영역"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">Stack 영역</span></span></a></li><li><a class="level is-mobile" href="#Heap-영역"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">Heap 영역</span></span></a></li><li><a class="level is-mobile" href="#Static-Data-Literals-영역"><span class="level-left"><span class="level-item">2.2.5</span><span class="level-item">Static Data, Literals 영역</span></span></a></li><li><a class="level is-mobile" href="#Instructions-영역"><span class="level-left"><span class="level-item">2.2.6</span><span class="level-item">Instructions 영역</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Process"><span class="level-left"><span class="level-item">3</span><span class="level-item">Process</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#그럼-대체-프로그램이랑-프로세스의-차이가-무엇인가"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">그럼 대체 프로그램이랑 프로세스의 차이가 무엇인가??</span></span></a></li></ul><li><a class="level is-mobile" href="#프로세스-생성-Process-Creation"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">프로세스 생성(Process Creation)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fetch"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">Fetch</span></span></a></li><li><a class="level is-mobile" href="#Allocation"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">Allocation</span></span></a></li><li><a class="level is-mobile" href="#The-OS-do-some-other-initializaion-tasks"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">The OS do some other initializaion tasks</span></span></a></li><li><a class="level is-mobile" href="#Decode-and-Execution"><span class="level-left"><span class="level-item">3.2.4</span><span class="level-item">Decode and Execution</span></span></a></li></ul></li><li><a class="level is-mobile" href="#프로세스-상태-Process-States"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">프로세스 상태(Process States)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-State-Model"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">5-State Model</span></span></a></li><li><a class="level is-mobile" href="#7-State-Model"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">7-State Model</span></span></a></li><li><a class="level is-mobile" href="#Ready-State-와-Blocked-Wait-State의-차이"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">Ready State 와 Blocked(Wait) State의 차이</span></span></a></li><li><a class="level is-mobile" href="#Preemption-과-Block-Wait-Sleep-의-차이"><span class="level-left"><span class="level-item">3.3.4</span><span class="level-item">Preemption 과 Block/Wait/Sleep 의 차이</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2021/09/29/OS-2/"><img src="/img/OS/os_cover.jpeg" alt="Process(프로세스)란??"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-29T11:18:15.000Z">2021-09-29</time></p><p class="title"><a href="/2021/09/29/OS-2/">Process(프로세스)란??</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/09/17/OS-1-5/"><img src="/img/OS/os_cover.jpeg" alt="Schematic Overview of Computer System"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-16T23:58:27.000Z">2021-09-17</time></p><p class="title"><a href="/2021/09/17/OS-1-5/">Schematic Overview of Computer System</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/09/10/OS-1/"><img src="/img/OS/os_cover.jpeg" alt="History of Operating System"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-10T07:10:27.000Z">2021-09-10</time></p><p class="title"><a href="/2021/09/10/OS-1/">History of Operating System</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/09/03/OS-0/"><img src="/img/OS/os_cover.jpeg" alt="Operating System Introduction"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-03T07:08:27.000Z">2021-09-03</time></p><p class="title"><a href="/2021/09/03/OS-0/">Operating System Introduction</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/22/openstack-2/"><img src="/img/openstack/openstack_cover.png" alt="Master Challenge - openstack server list 명령어 동작 원리 파악하기"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-08-22T07:10:27.000Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/openstack-2/">Master Challenge - openstack server list 명령어 동작 원리 파악하기</a></p><p class="categories"><a href="/categories/OpenStack/">OpenStack</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Jiho Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Jiho Ju</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>