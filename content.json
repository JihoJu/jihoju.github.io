{"pages":[{"title":"about","text":"Github 안녕하세요 현재 경북대학교 3학년에 재학 중인 주지호 입니다. 현재 관심있는 분야는 Cloud Computing, Backend 입니다. 또한, Data 분야에 관심이 가서 통계학을 부전공으로 공부하고 있습니다. “하루는 성실하게. 인생 전체는 되는대로” - 이동진(‘밤은 책이다’ 중에서) 라는 말씀을 제 인생의 방향으로 섬기며 살고 있습니다. 아직은 어떤 분야에 기여를 할 지 모르지만 미래에 사람들에게 들려줄 이야기가 많은 개발자가 되도록 오늘도 성실하게 달립니다!!!! Skills Python, C Django, Flask OpenStack Projects Contributon OpenStack OpenSource Project - 2021.09 ~","link":"/about/index.html"}],"posts":[{"title":"1 - Operating System Introduction","text":"들어가며평소에 개발자로 성장하기에 있어 Operating System 은 아주 중요하다는 얘기를 종종 듣게된다. 아직 현업에서 일해보지 않아 어떤 일을 하는데 있어 필요한지 경험을 해보진 못했지만 이번 OS 수업을 수강하며 최대한 이해하고 정리한 내용을 포스팅 하려고 합니다. 교수님의 수업 자료와 Operating Systems: Three Easy Pieces를 기반으로 정리하여 포스팅하려 합니다. Computer Science vs Engineering Science: 이론, 연구를 통해 정답을 도출하는 과정 Engineering: 주어진 환경 속에서 문제를 해결하는 과정 What is a Computer or Computer SystemApplication Software High Level Language 로 작성된다. (C/C++, Python, SQL …) System Software Compiler : HLL 을 Machine code 로 translate 해준다. Operating System : hardware 를 관리하는데 있어 다양한 concept 들을 제공해준다. (Window, Unix, Linux, DOS …) Handling input/output Managing memory &amp; storage Scheduling tasks &amp; sharing resources Computer Hardware Processor, Memory, I/O controllers What is Operating System왜 Why? OS 가 hardware 를 관리해주는가?? OS 역사를 봤을 때 초기엔 OS 가 아닌 컴퓨터 사용자가 직접 hardware 를 관리를 해줬다. 시간이 지나며 hardware 는 성능이 좋아지고 점점 더 복잡해졌다. 그로 인해 각 user 들이 관리하기 힘들어졌을 뿐만 아니라 직접 관리의 위험성이 커졌다. 그래서 hardware 를 관리해주는 OS 가 필요해지며 나타났다. Users applications 와 computer hardware 사이에 있는 Software layer 이다. ⇒ computer hardware 와 user applications software 를 interfacing 해준다. System call library : Hardware 가 관리하는 서비스를 사용. 즉, Hardware 와 통신하는 통로 ⇒ 안정성을 위함. Two Perspectives in Operationg SystemHardware 관점제한된 자원을 관리 Hardware Resources 를 효율적으로 관리 → maximize the performance ⇒ 한정된 자원으로 컴퓨터의 최대의 성능을 내기 위함 Hardware Resources 를 공평하게 할당(분배) → guarantee user experience ⇒ 다양한 접근(Multiprogramming)에 대해 공정하게 자원들을 분배 guarantee user experience? : 만약 한 자원에 여러 access 가 있을 시 한 access 요청이 끝날 때 까지 자원을 할당해주게 되면 뒤에 있는 다른 access 들은 아무것도 안하고 기다리고 있을 수 있다. 이러한 현상을 방지하기 위해 Round Robin 방식으로 자원을 공정하게 할당해주면 다양한 접근들에 효율적으로 자원을 분배할 수 있을 것이다. Applications 관점Computer System 을 편리하게 사용하게 함 User program 을 실행해주고 User Problems 을 해결해준다. A role of Operating Systems 각 사용자가 하드웨어 자원들을 독점하게끔 느낄 수 있도록 illusion 을 제공한다. Virtualization 복잡한 하드웨어 구조들을 숨겨주면서 사용자들이 컴퓨터 하드웨어를 편리하게 사용하게끔 해준다. Abstraction Three Main Features of Operating Systems현대 OS는 3개의 목적을 위해 다양한 기법들이 개발되었고 현재에도 개발되고 있다. 이 책에서는 3가지 목적을 위해 OS가 등장했다고 소개하고 있다. 그럼 어떤 목적이 있고 각 목적이 어떤 담당을 하는지 간단하게 정리해보겠다. 이번 글은 각 개념을 소개하는 글이므로 추후에 각 개념에 대해 자세히 정리해서 포스팅 하겠습니다:) Virtualization CPU Virtualization (Scheduling, Process, …) 한 개의 CPU(or 프로세서)에서 여러 개의 프로그램들이 동시에 실행되는 것처럼 보이게끔 해준다. 사용 시스템이 여러 개의 CPU를 가지고 있다는 illusion(환상)을 준다. Memory Virtualization (Paging, Address Translation…) 각 프로그램(프로세스)들이 자기만의 크고 빠른 메로리를 가지고 있다는 illusion을 준다. 실제 Physical memory 는 OS에 관리되는 한정된 공유 자원이다. 이 자원을 메모리 간섭 없이 각 프로세스가 자신만의 가상 주소 공간을 가지고 있다고 illusion(환상)을 준다. Concurrency동시에 프로그램들을 여러 개 수행해도 한 프로그램을 실행할 때와 동일하게 결과로 처리하겠다는 개념이다. Threads, Locks and semaphores, Deadlocks… Persistence이 개념은 “신뢰성” 이란 단어로 표현 가능할 거 같다. 예를 들어 과제를 하고 저장을 했다. 이 과제를 언제든지 불러오고 수정하고 다시 저장하는 과정을 오류없이 할 수 있어야하기 때문에 이러한 관점에서 persistence 라는 개념은 신뢰성을 의미한다. 만약 10시간을 해서 끝마친 과제를 발표를 위해 불러오려고 했는데 없어지거나 내용이 바뀌면,,,? 상상도 하기 싫다… File System I/O Devices Journaling OS가 어디에 사용되는지와 목적에 따라 3가지 개념의 중요도가 달라진다. → 현대에는 3가지 개념이 없는 OS는 없다.","link":"/2021/09/03/OS-0/"},{"title":"2 - History of Operating System","text":"들어가며OS에도 역사가 있다. OS-1 글에도 적어놨듯이 컴퓨터가 최초로 나왔을 때부터 OS가 있었던 것은 아니었다. 필요에 의해 지금의 OS가 개발된 것이다. 그럼 어떤 필요에 의해 어떤 OS의 기능들이 필요로 해서 현재 OS가 탄생했는지 정리해보려 한다. Serial processing ~ 1950s이 시기는 하드웨어는 무척 비쌌지만, 인건비는 매우 쌌다. 그래서 천공카드니 뭐니 사람이 하드웨어를 직접 관리한 시기다. 당연히 이때는 OS가 존재하지 않았으니,,, 이 시기에 목적은 하드웨어의 효율적인 사용이다. 정확히 말하면 하드웨어가 쉴 틈이 없이 동작하게 하는 것이 목적이었다. 특징 Objective: 하드웨어를 효율적으로 사용 No operating systems (Single) Batch processing ~ 1960sBatch processing?? 이 개념이 무엇이고 대체 왜 도입이 됐는지 확인해보자. 1번 시기의 목적은 하드웨어의 효율적인 사용이다. 그리고 사람이 하드웨어를 관리하는 시기다. 다음 [그림-1]을 보면 각 job이 시작되기 전에 setup 하고 끝나면 takedown 을 하는 시간이 소요가 되는 것을 볼 수 있다. 이 시기의 목적이 하드웨어의 효율적인 사용인데 [그림-1] (a)를 보면 비싼 하드웨어가 놀고 있는 시간이 많은 것을 볼 수 있다. 그래서 각 job 들 중간에 있는 overhead 를 줄이기 위해 나온 것이 Batch 이다. Batch processing : 일괄 처리하는 과정으로 실시간으로 요청에 의해 처리되는 방식이 아닌 위와 같이 모든 job(프로세스)들을 처리하는 방식이다. 이 시기의 주 목적은 setup 과 takedown 시간을 줄여서 CPU utilization 을 향상시키는 것이다. Batch processing을 통해 [그림-1] (b)를 보면 어느정도 문제를 해결한 것으로 보인다. 하지만 다음 [그림-2]을 보면 여전히 CPU utilization이 나쁘다는 것을 볼 수 있다. 12345Read one record from file : 15 usExecute 100 instructions in processor : 1 usWrite one record to file : 15 usTotal : 31 usPercent CPU utilization = 1/31 = 0.032 = 3.2% 메모리 읽고 쓰는 속도보다 CPU의 속도가 훨씬 빠르니 이러한 문제는 당연하다. 그럼 [그림-2]의 문제를 해결하는 것은 생각? 이론 상으로는 간단하다. I/O 동안 CPU를 다른 곳에 쓰면 되는 것이다. 그래서 나온 개념이 Multiprogramming batch processing 이다. Multiprogramming batch processing 1960s~1970s2번 시기에 setup 과 takedown 시간을 줄여 CPU utilization을 향상시켰지만 그럼에도 여전히 CPU utilization은 나빴다. 그래서 이를 해결하고자 I/O로인한 CPU가 쉬는 시간을 없애고 다른 곳에 쓰이도록 하는 Multiprogramming batch processing 이란 개념이 나왔다. 위의 [그림-3]처럼 I/O 기간에 다른 Job 들을 처리하면 CPU utilization이 극대화될 것이다. 이를 위해선 해당 Job들이 미리 메모리에 올라와 관리되야한다. 이렇게 하는 이유는 CPU가 각 Job들을 사이에서 switch 할 수 있게 하여 가능한 CPU 가 최대한 바쁘게 만들기 위함이다. 즉, CPU utilization 향상을 위해!! 해당 Job(task, process) 들이 미리 메모리에 업로드 되야하니 Memory Relocation 이란 개념이 나타났고 서로 메로리를 간섭하면 안되니 Memory Protection 이란 개념이 나타났다. 그럼 Job 1이 수행되다가 I/O가 호출되어 CPU는 switch를 했는데 어떤 Job을 다음에 수행해야하지?? 해서 나온 개념이 Process Scheduler 이다. 다시 말하지만 이 시기의 주 목적은 느린 I/O 동작을 최대한 숨기고 overlap of computation with asynchronous I/O 하여 CPU utilization을 향상시키는 것이다. (영어로 쓴 건 한국어로 번역하게 되면 의미가 이상해 보여서입니다. ㅠㅠ) I/O 종류 Synchronous I/O CPU가 Job을 처리하는 도중 I/O 호출 → CPU는 I/O 동작이 끝날 때까지 기다린다. Asynchronous I/O 위와 반대로 CPU가 Job을 처리하는 도중 I/O 호출이 되면 context switch를 통해 다른 작업을 수행한다. Memory relocation [그림-4]에서 왼쪽은 가상 메모리 이다. 이 가상 메모리를 실제 Physical 메모리에 넣는 것이 memory relocation 이다. 이 과정은 목적에 맞는 다양한 정책과 결정이 필요하며 OS가 처리한다. Base/bound registersMMU(Memory Management Unit)의 초기 형태 Base registers: 실제 Physical 메모리 시작 주소를 담고 있다. Bound registers: Job(프로세스)에 할당된 공간양? 용량을 담고있다. 하드웨어의 지원으로 어떻게 하면 이 것을 최적화 시킬까??를 고민하고 나온 것이 현대적 OS 이다. 예를 들어 레지스터 2개가 지원이 된다 → 오 그럼 시작 주소랑 메모리 용량 2개를 저장해서 memory relocation 을 최적화 하면 되겠다. Memory protection [그림-7]과 같이 각 Job 들끼리 간섭이 일어나면 안된다!! Concurrency and Synchronization해당 글은 OS의 역사를 주제로 정리한 글이니 자세한 내용은 추후에 정리하도록 하겠습니다. **”Concurrency를 보장한다”**는 간단히 말하자면 동시 여러 Program끼리 간섭이 되지 않는 것을 보장한다와 같은 말이다. 만약 공유되는 counter 라는 변수를 증가시키는 명령문이 있다고 가정해보자. 메모리로부터 counter 라는 변수의 값을 레지스터에 Load 시켜줘야한다. 이것을 1 증가시킨다. 이것을 다시 메모리에 store 해준다. 이렇게 3개의 명령문은 atomically 하게 실행되는 않아 실행되는 과정에서 Concurrency를 보장해주지 않는다고 가정하면 다음과 같은 문제가 발생한다. 각 프로세스에서 1을 한번씩 더하면 값은 8이 나와야 하는데 결국 값이 7이 됐다. 좀 더 자세히 설명을 덧붙이자면 Process A 에서 counter=6을 업로드하고 1을 증가시켜주기 전에 갑자기 I/O호출이나 time slicing 시간이 끝나서 Process B로 switch 된다. 아직 Process A 에서 counter 의 값을 1 증가시켜주고 이를 메모리에 저장하는 과정을 수행하지 않아 Process B는 counter=6을 메모리에서 업로드 한다. 이 과정 때문에 그림과 같이 Concurrency 에 대한 에러가 발생한 것이다. 이는 여러 정책과 기법으로 해결을 해줘야 한다. 이는 추후에 다시 정리하도록 하겠다. 이를 Concurrency and Synchronization이 보장되지 않는 것을 현실 문제로 생각해보자. SMS 앱과 메일 앱이 있고 같은 시간에 메세지 앱에 “안녕하세요” 메세지가 왔고 메일 앱에 “하이요!” 메일이 왔다고 가정하자. 만약 이 두 내용이 메모리에 write 될 때 간섭이 발생하게 되면 “안하녕하이세!요” 같이 데이터가 충돌이 날 수 있다. 마찬가지로 은행 계좌를 생각해보면 concurrency 가 보장이 안되면 끔찍한 일들이 발생할 것이다. Time-sharing processing 1970s~1980s이제 이 시기로 오면서 CPU, 하드웨어에 초점이 맞춰졌다면 이제는 각 사용자가 어떻게 느끼는지? 또한 중요한 고려 요소가 되면서 이 시기의 주 목적은 Response time을 최소화시키는 것이다. Time-sharing processing은 Batch-multiprogramming system의 논리적 확장이다. CPU가 여러 Job들을 빈번하게 switch 하면서 multiple user들이 각 job들과 상호작용할 수 있게함으로써 interative computing(sharing the computer hardware resource) 이란 개념이 생겨났다. 하지만 이 개념은 illusion 을 주는 것이다. 예를 들어, single CPU 라고 가정 시 동시에 4개의 프로그램들이 running 하고 있다고 가정해보자. time sharing 을 통해 다음과 같은 순서대로 실행되지만 실행되는 속도는 매우 빨라 4개의 프로그램들이 겉보기에 동시에 실행되는 것처럼 보여 사용자 입장에서는 실시간으로 결과가 나오는 줄 알고 착각하게된다. 즉, CPU의 개수가 여러 개라는 환상(illusion)을 제공해주는 것이다. 근데 만약 한 연산(Job, 프로세스)이 I/O는 없고 연산할 것이 엄청 많다면 CPU는 한동안 그 작업만 처리해야하고 다른 작업은 처리를 할 수 없게 되어 다른 작업의 response time 이 올라가게 되어 사용자 경험이 안좋아지게될 것이다. 그래서 나온 개념이 Time Slicing 으로 공평하게 각 작업들에게 시간을 줘서 Round Robin 방식(자세한 내용은 추후에 정리)으로 스케줄링 시켜준다. ⇒ OS는 한정된 자원을 공평하게 분배를 하기 위함이다. 이렇게 Response time을 최소화시켜 User experience를 향상시키는 것이 이 시기의 주 목적이다. Real time System이 개념은 **”Fast”**와 무관하다. 정확한 개념은 주어진 시간동안 이 작업을 꼭 끝낼 수 있느냐? 이다. 즉, “Dead Line을 지킬 수 있느냐 없느냐” 이다. 예를 들면 1+1 요청의 응답이 1초 안에 올 수 있도록 보장할 수 있느냐의 약속이라고 생각하면 될 것이다. Hard real-time system 이 데드라인을 어기면 사람이 죽을 수 있을 정도로 정말 데드라인을 꼭 보장해야하는 시스템 (예) 비행기 시스템 Soft real-time system 어겨도 되긴 되지만 어기면 사용자들이 짜증이 나고 service 퀄리티가 떨어진다. QoS(Quality of Service): 다른 응용 프로그램, 사용자, 데이터 흐름 등에 우선 순위를 정하여, 데이터 전송에 특정 수준의 성능을 보장하기 위한 능력으로 사용자 경험에 영향을 많이 받음과 동시에 주기도 한다. 맺으며Operating System 은 내가 태어나기도 전부터 나타난 거라 아무런 생각 없이 당연하게 사용해왔다.(사용했다기보다 아예 신경을 안 썼다) 개발을 하면 항상 “그거 왜 사용해?”라는 질문을 많이 받곤 한다. 역사적으로 왜 생겨났으며 어떻게, 어디에 사용되는 지에 대한 설명이 위 질문에 가장 좋은 대답이라 생각한다. 이번 글을 포스팅하며 OS가 어떻게 나타나고 현대 컴퓨터에 왜 없어서는 안 될 시스템인지 공부할 수 있었다.","link":"/2021/09/10/OS-1/"}],"tags":[],"categories":[{"name":"OS","slug":"OS","link":"/categories/OS/"}]}